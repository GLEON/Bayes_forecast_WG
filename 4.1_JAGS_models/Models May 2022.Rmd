---
title: "GLOEO space _ May2022"
author: "LaDeau"
date: "5/11/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, readxl, rjags, runjags, moments, coda)

#set a directory to use as a local file repository for plots if desire to write to file
#my_directory <- "C:/Users/ladeaus/Documents/GLEON/Brentrup" 
my_directory <- "~/Documents/Gloeo Bayesian Modeling/R Output/Bayes_model_calibration_output/"

```

# Read in Data Single Site
```{r}
###get calibration data - 1 site
#read in data matrix
gloeo <- read_csv("./00_Data_files/Bayesian_model_input_data/data_site_model_format.csv")
#gloeo is already on log scale, covars are already standardized


#model below requires data with k obs: y, covar1, covar2, week_avg1, week_avg2, 
#and constants mu.0, a_proc,r_proc, a_obs,r_obs, seasons_weeks, site_no
y=gloeo$y
covar1=gloeo$Temp
covar2=gloeo$GDD
week_avg1=gloeo$week_avg1
week_avg2=gloeo$week_avg2
mu.0=-10 ###-10 true value still on log scale but close to zero? -4.95 0+1/141.4 =0.007
a_obs=0.01; r_obs=0.01
a_proc=0.01; r_proc=0.01
season_weeks=gloeo$season_weeks
year_no = gloeo$year_no
#year_no = c(1:8)
```

# Read in Data Multi Site ###
```{r}
###get calibration data - 1 site
#read in data matrix
gloeo <- read_csv("./00_Data_files/Bayesian_model_input_data/data_4site_model_format.csv")
#gloeo is already on log scale, covars are already standardized


#model below requires data with k obs: y, covar1, covar2, week_avg1, week_avg2, 
#and constants mu.0, a_proc,r_proc, a_obs,r_obs, seasons_weeks, site_no
y=as.matrix(gloeo[,3:5])
covar1=as.matrix(gloeo[,7:9])
covar2=as.matrix(gloeo[,11:13])
week_avg1=gloeo$week_avg1
week_avg2=gloeo$week_avg2
mu.0=-10 ###-10 true value still on log scale but close to zero? -4.95 0+1/141.4 =0.007
a_obs=0.01; r_obs=0.01
a_proc=0.01; r_proc=0.01 #0.001
season_weeks=c(1:160)
year_no = as.numeric(as.factor(gloeo$year))

```

## Random Walk run - converges fine

```{r}
##Random Walk run - converges fine
data.rw <- list(y=y,n=length(season_weeks),x_ic=log(1000),tau_ic=100,a_obs=1,r_obs=1,a_add=1,r_add=1)

RandomWalk = "
model{
  
  #### Data Model
  for(t in 1:n){
    y[t] ~ dnorm(x[t],tau_obs)
  }
  
  #### Process Model
  for(t in 2:n){
    x[t]~dnorm(x[t-1],tau_add)
  }
  
  #### Priors
  x[1] ~ dnorm(x_ic,tau_ic)
  tau_obs ~ dgamma(a_obs,r_obs)
  tau_add ~ dgamma(a_add,r_add)
}
"

nchain = 3
init <- list()
for(i in 1:nchain){
  y.samp = sample(y,length(y),replace=TRUE)
  init[[i]] <- list(tau_add=1/var(diff(y.samp),na.rm=T),tau_obs=5/var(y.samp,na.rm=T))}
  
  
j.model_RW   <- jags.model (file = textConnection(RandomWalk),
                             data = data.rw,
                             inits = init,
                             n.chains = 3)  



jags.out_RW   <- coda.samples (model = j.model_RW,
                            variable.names = c("tau_add","tau_obs"),
                            n.iter = 1000)
plot(jags.out_RW)
```


## Dynamic linear
```{r}

data <- list(y=y,WK=length(season_weeks), covar1=covar1, covar2=covar2, week_avg1=week_avg1, week_avg2=week_avg2, a_obs=a_obs, r_obs=r_obs, a_proc=a_proc,r_proc=r_proc,x_ic=-6,tau_ic=0.1)


mod1 = "
model{
  
  #### Data Model
  for(t in 1:WK){
    y[t] ~ dnorm(x[t],tau_obs)
        covar1[t] ~ dnorm(week_avg1[t],0.1)
        covar2[t] ~ dnorm(week_avg2[t],0.1)

  }
  
  #### Process Model
  for(t in 2:WK){
    x[t]~dnorm(lam[t],tau_add)
    lam[t]=beta1 + beta2*x[t-1] + beta3*covar1[t] + beta4 * covar2[t] + beta5 * covar2[t]^2 # lam or x on beta2? x trace plots look better
}
  
  #### Priors
  x[1] ~ dnorm(x_ic,tau_ic)
  lam[1] ~ dnorm(x_ic,tau_ic)

  beta1~dnorm(0,0.01)
  beta2~dnorm(0,0.01)
  beta3~dnorm(0,0.01)
  beta4~dnorm(0,0.01)
  beta5~dnorm(0,0.01)

  tau_obs ~ dgamma(a_obs,r_obs)
  tau_add ~ dgamma(a_proc,r_proc)
}
"

j.model_DL   <- jags.model (file = textConnection(mod1),
                             data = data,
                             inits = init,
                             n.chains = 3)  



jags.out_DL   <- coda.samples (model = j.model_DL,
                            variable.names = c("tau_add","tau_obs","beta1","beta2","beta3","beta4","beta5"),
                            n.iter = 10000)
plot(jags.out_DL)

summary(jags.out_DL)

DL_var.mat <- as.matrix(jags.out_DL)
pairs(DL_var.mat)
cor(DL_var.mat)

# Calculate DIC
DIC.DL <- dic.samples(j.model_DL, n.iter=5000)
DIC.DL
  
```

## Dynamic linear with Random Year Effect
```{r}

data <- list(y=y,
             WK=length(season_weeks), 
             year_no = year_no,
             totYr = length(unique(year_no)),
             covar1=covar1, 
             covar2=covar2, 
             week_avg1=week_avg1, 
             week_avg2=week_avg2, 
             a_obs=a_obs, r_obs=r_obs,
             a_proc=a_proc,r_proc=r_proc,
             x_ic=-6,tau_ic=0.1)


mod1 = "
model{

  #### Data Model
  for(t in 1:WK){
    y[t] ~ dnorm(x[t],tau_obs)
        covar1[t] ~ dnorm(week_avg1[t],0.1)
        covar2[t] ~ dnorm(week_avg2[t],0.1)

  }
  
  #### Process Model 
  for(t in 2:WK){
    x[t]~dnorm(lam[t],tau_add)
    lam[t]=beta1 + beta2*x[t-1] + beta3*covar1[t] + beta4 * covar2[t] + beta5 * covar2[t]^2 + yr[year_no[t]]
  
}
  
  #### Priors

for(k in 1:totYr){
  yr[k] ~ dnorm(0, tau_yr) # k loop on yr
  }

  x[1] ~ dnorm(x_ic,tau_ic)
  lam[1] ~ dnorm(x_ic,tau_ic)

  beta1~dnorm(0,0.01)
  beta2~dnorm(0,0.01)
  beta3~dnorm(0,0.01)
  beta4~dnorm(0,0.01)
  beta5~dnorm(0,0.01)

  tau_obs ~ dgamma(a_obs,r_obs)
  tau_add ~ dgamma(a_proc,r_proc)
  tau_yr ~ dgamma(0.01,0.01)
  
}
"

j.model_DL_RY   <- jags.model (file = textConnection(mod1),
                             data = data,
                             inits = init,
                             n.chains = 3)  



jags.out_DL_RY   <- coda.samples (model = j.model_DL_RY,
                            variable.names = c("beta1","beta2","beta3","beta4","beta5", "tau_add","tau_obs", "tau_yr", "yr"),
                            n.iter = 10000)
plot(jags.out_DL_RY)

summary(jags.out_DL_RY)

var.mat <- as.matrix(jags.out_DL_RY)
pairs(var.mat)
cor(var.mat)

# Calculate DIC
DIC.DL_RY <- dic.samples(j.model_DL_RY, n.iter=5000)
DIC.DL_RY
```


## Dynamic linear with multiple sites


```{r}

data <- list(y=y,
             WK=length(season_weeks), 
             site_no = 1:3,
             covar1=covar1, 
             covar2=covar2, 
             week_avg1=week_avg1, 
             week_avg2=week_avg2, 
             a_obs=a_obs, r_obs=r_obs, 
             a_proc=a_proc,r_proc=r_proc,
             x_ic=-6,tau_ic=0.1)


mod1 = "
model{
  
  #### Data Model
for(j in 1:max(site_no)) {

  for(t in 1:WK){
    y[t,j] ~ dnorm(x[t,j],tau_obs)
        covar1[t,j] ~ dnorm(week_avg1[t],0.1) #make a matrix
        covar2[t,j] ~ dnorm(week_avg2[t],0.1)

  }
  
  #### Process Model
  for(t in 2:WK){
    x[t,j]~dnorm(lam[t,j],tau_add)
    lam[t,j]=beta1 + beta2*x[t-1,j] + beta3*covar1[t,j] + beta4*covar2[t,j] + beta5*covar2[t,j]^2
}
  

  #### Initial Conditions
  x[1,j] ~ dnorm(x_ic,tau_ic)
  lam[1,j] ~ dnorm(x_ic,tau_ic)

}



#### Priors
  beta1~dnorm(0,0.01)
  beta2~dnorm(0,0.01)
  beta3~dnorm(0,0.01)
  beta4~dnorm(0,0.01)
  beta5~dnorm(0,0.01)

  tau_obs ~ dgamma(a_obs,r_obs)
  tau_add ~ dgamma(a_proc,r_proc)
  
}
"

j.model_DL_3sites   <- jags.model (file = textConnection(mod1),
                             data = data,
                             inits = init,
                             n.chains = 3)  



jags.out_DL_3sites   <- coda.samples (model = j.model_DL_3sites,
                            variable.names = c("tau_add","tau_obs","beta3","beta4","beta5"),
                            n.iter = 10000)
plot(jags.out_DL_3sites)

summary(jags.out_DL_3sites)
gelman.diag(jags.out_DL_3sites)

DL_var.mat <- as.matrix(jags.out_DL_3sites)
pairs(DL_var.mat)
cor(DL_var.mat)

# Calculate DIC
DIC.multi <- dic.samples(j.model_DL_3sites, n.iter=5000)
DIC.multi
  
```


## Dynamic linear with Multiple sites + Random Year Effect
```{r}

data <- list(y=y,
            WK=length(season_weeks), 
            site_no = length(1:3),
             year_no = year_no, # same length as season weeks
             totYr = length(unique(year_no)), # vector length of total number of years 8
             covar1=covar1, 
             covar2=covar2, 
             week_avg1=week_avg1, 
             week_avg2=week_avg2, 
             a_obs=a_obs, r_obs=r_obs,
             a_proc=a_proc,r_proc=r_proc,
             x_ic=-6,tau_ic=0.1)

# init <- list()
# for(i in 1:nchain){
#   y.samp = sample(y,length(y),replace=TRUE)
#   init[[i]] <- list(tau_add=1/var(diff(y.samp),na.rm=T),tau_obs=5/var(y.samp,na.rm=T))}

init <- list(list(tau_add=0.001, tau_obs = 0.1,tau_C1_proc = 0.01,tau_C2_proc = 0.01, 
                  beta1=-2, beta2=-0.5, beta3=0, beta4=0, beta5=0),
    list(tau_add=0.1,tau_obs = 1,tau_C1_proc = 0.1,tau_C2_proc = 0.1, 
         beta1=-1.5, beta2=0, beta3=0.5, beta4=0.5, beta5=0.5),
    list(tau_add=1, tau_obs = 5,tau_C1_proc = 1,tau_C2_proc = 1, 
         beta1=-1,beta2=0.5, beta3=1, beta4=1, beta5=1))

# init <- list()
# for(i in 1:nchain){
#   y.samp = sample(y,length(y),replace=TRUE)
#   init[[i]] <- list(tau_add=1/var(diff(y.samp),na.rm=T),tau_obs=5/var(y.samp,na.rm=T))}

mod1 = "
model{
  
  #### Data Model
for(j in 1:site_no) {

  for(t in 1:WK){
    y[t,j] ~ dnorm(x[t,j],tau_obs)
        covar1[t,j] ~ dnorm(week_avg1[t],0.1) #make a matrix
        covar2[t,j] ~ dnorm(week_avg2[t],0.1)

  }
  
  #### Process Model
  for(t in 2:WK){
    x[t,j]~dnorm(lam[t,j],tau_add)
    lam[t,j]=beta1 + beta2*lam[t-1,j] + beta3*covar1[t,j] + beta4*covar2[t,j] + beta5*covar2[t,j]^2 + yr[year_no[t]]
    #lam[t,j]=beta[1] + beta[2]*lam[t-1,j] + beta[3]*covar1[t,j] + beta[4]*covar2[t,j] + beta[5]*covar2[t,j]^2 + yr[year_no[t]]

}
  

  #### Initial Conditions
  x[1,j] ~ dnorm(x_ic,tau_ic)
  lam[1,j] ~ dnorm(x_ic,tau_ic)

}



for(k in 1:totYr){
  yr[k] ~ dnorm(beta1, tau_yr) # k loop on yr, centered on beta1 instead of 0 helps!
}


#### Priors

# for(i in 1:5) {
#   beta[i] ~ dnorm(0,0.001) #worse, need to set init values somehow
# }


  beta1~dnorm(0,0.001)
  beta2~dnorm(0,0.001)
  beta3~dnorm(0,0.001)
  beta4~dnorm(0,0.001)
  beta5~dnorm(0,0.001)

 # tau_C1_proc ~ dgamma(0.01,0.01)
 # tau_C2_proc ~ dgamma(0.01,0.01)
  tau_obs ~ dgamma(a_obs,r_obs)
  tau_add ~ dgamma(a_proc,r_proc)
  tau_yr ~ dgamma(0.01,0.01) #keep prior in same space
  
}
"

j.model_DL_RY_3sites   <- jags.model (file = textConnection(mod1),
                             data = data,
                             inits = init,
                             n.chains = 3)  



jags.out_DL_RY_3sites  <- coda.samples (model = j.model_DL_RY_3sites,
                            variable.names = c("beta1","beta2","beta3","beta4","beta5", "tau_add","tau_obs", "tau_yr", "yr"), 
                            n.iter = 50000) #10000

#"beta[1]","beta[2]","beta[3]","beta[4]","beta[5]",
#"beta1","beta2","beta3","beta4","beta5", 
plot(jags.out_DL_RY_3sites)

summary(jags.out_DL_RY_3sites)
gelman.diag(jags.out_DL_RY_3sites)

GBR <- gelman.plot(jags.out_DL_RY_3sites) #The point up to where the GBR drops below 1.05 is termed the "burn in" period

burnin = 10000                              ## determine convergence
jags.burn <- window(jags.out_DL_RY_3sites,start=burnin)  ## remove burn-in
plot(jags.burn)

gelman.diag(jags.burn)

var.mat <- as.matrix(jags.out_DL_RY_3sites)
cor(var.mat)
pairs(var.mat)


# Calculate DIC
DIC.multi_RY <- dic.samples(j.model_DL_RY_3sites, n.iter=5000)
DIC.multi_RY
```

# GLM to find initial values for betas
```{r}
multi_RY_fit <- glm(gloeo$hc_gloeo_ln ~ gloeo$HCS.tempC_min_stand + gloeo$GDD_hc + (gloeo$GDD_hc^2))
summary(multi_RY_fit)

multi_RY_fit2 <- lm(gloeo$hc_gloeo_ln ~ gloeo$HCS.tempC_min_stand + gloeo$GDD_hc + (gloeo$GDD_hc^2))
summary(multi_RY_fit2)

multi_RY_fit2 <- lm(gloeo$nb_gloeo_ln ~ gloeo$NB.tempC_min_stand + gloeo$GDD_nb + (gloeo$GDD_nb^2))
summary(multi_RY_fit2)

multi_RY_fit2 <- lm(gloeo$nsh_gloeo_ln ~ gloeo$NSH.tempC_min_stand + gloeo$GDD_nsh + (gloeo$GDD_nsh^2))
summary(multi_RY_fit2)
```


## Ho Model - single site (HC) 1 covariate min water temp

Add in linear model on standard deviation, allows for variance to be non-constant
 s[i] <- alpha1 + alpha2*x[i]  ## linear model on standard deviation of x
 
  S[i] <- 1/s[i]^2  ## calculate precision from SD
 
```{r}

data <- list(y=y,
             WK=length(season_weeks), 
             covar1=covar1, 
             covar2=covar2, 
             week_avg1=week_avg1, 
             week_avg2=week_avg2, 
             a_obs=a_obs, r_obs=r_obs, 
            # a_proc=a_proc,r_proc=r_proc,
             x_ic=-6,tau_ic=0.1)

nchain = 3
init <- list()
for(i in 1:nchain){
  y.samp = sample(y,length(y),replace=TRUE)
  init[[i]] <- list(S_add=1/var(diff(y.samp), na.rm = T),tau_obs=5/var(y.samp,na.rm=T))}

#S_add=8, 

init <- list(list(tau_obs = 0.1, S_add = 1000000,
          beta1=-2, beta2=-0.5, beta3=0),
    list(tau_obs = 1, S_add = 1000010,
         beta1=-1.5, beta2=0, beta3=0.5),
    list(tau_obs = 5, S_add = 1000100,
         beta1=-1,beta2=0.5, beta3=1))


mod1 = "
model{
  
  #### Data Model
  for(t in 1:WK){
    y[t] ~ dnorm(x[t],tau_obs)
        covar1[t] ~ dnorm(week_avg1[t],0.1)
        covar2[t] ~ dnorm(week_avg2[t],0.1)

  }
  
  #### Process Model
  for(t in 2:WK){
    x[t]~dnorm(lam[t],S_add[t]) # replace tau_add with linear model
    lam[t]=beta1 + beta2*lam[t-1] + beta3*covar1[t]
    #S_add[t] = alpha1 + alpha2*lam[t] 
    S_add[t] = 1/pow(alpha1 + alpha2*lam[t], 2) # written as precision 1/sd squared
}
  
  #### Priors # add prior for alphas
  x[1] ~ dnorm(x_ic,tau_ic)
  lam[1] ~ dnorm(x_ic,tau_ic)


  beta1~dnorm(0,0.001)
  beta2~dnorm(0,0.001)
  beta3~dnorm(0,0.001)
  #beta4~dnorm(0,0.001)
  #beta5~dnorm(0,0.001)

  alpha1~dlnorm(0,0.001) #log normal variance can't be negative
  alpha2~dlnorm(0,0.001) #log normal variance can't be negative

  tau_obs ~ dgamma(a_obs,r_obs)
  #tau_C1_proc ~ dgamma(0.01,0.01)
  #tau_C2_proc ~ dgamma(0.01,0.01)

  #tau_add ~ dgamma(a_proc,r_proc)

}
"

j.model_Hetero   <- jags.model (file = textConnection(mod1),
                             data = data,
                             inits = init,
                             n.chains = 3)  



jags.out_Hetro   <- coda.samples (model = j.model_Hetero,
                            variable.names = c("tau_obs","beta1","beta2","beta3", "alpha1", "alpha2"), #"tau_add",
                            n.iter = 10000)
plot(jags.out_Hetro)

summary(jags.out_Hetro)

DL_var.mat <- as.matrix(jags.out_Hetro)
pairs(DL_var.mat)
cor(DL_var.mat)
  

# Calculate DIC
DIC.hetero <- dic.samples(j.model_Hetero, n.iter=5000)
DIC.hetero #lower than homo
  
```

## Ho Model - single site (HC) 2 covariates

Add in linear model on standard deviation, allows for variance to be non-constant
 s[i] <- alpha1 + alpha2*x[i]  ## linear model on standard deviation of x
 
  S[i] <- 1/s[i]^2  ## calculate precision from SD
 
```{r}

data <- list(y=y,
             WK=length(season_weeks), 
             covar1=covar1, 
             covar2=covar2, 
             week_avg1=week_avg1, 
             week_avg2=week_avg2, 
             a_obs=a_obs, r_obs=r_obs, 
            # a_proc=a_proc,r_proc=r_proc,
             x_ic=-6,tau_ic=0.1)

nchain = 3
init <- list()
for(i in 1:nchain){
  y.samp = sample(y,length(y),replace=TRUE)
  init[[i]] <- list(S_add=1/var(diff(y.samp),na.rm=T),tau_obs=5/var(y.samp,na.rm=T))}


mod1 = "
model{
  
  #### Data Model
  for(t in 1:WK){
    y[t] ~ dnorm(x[t],tau_obs)
        covar1[t] ~ dnorm(week_avg1[t],0.1)
        covar2[t] ~ dnorm(week_avg2[t],0.1)

  }
  
  #### Process Model
  for(t in 2:WK){
    x[t]~dnorm(lam[t],S_add[t]) # replace tau_add with linear model
    lam[t]=beta1 + beta2*lam[t-1] + beta3*covar1[t] + beta4 * covar2[t] + beta5 * covar2[t]^2
    #S_add[t] = alpha1 + alpha2*lam[t] 
    S_add[t] = 1/pow(alpha1 + alpha2*lam[t], 2) # written as precision 1/sd squared
}
  
  #### Priors # add prior for alphas
  x[1] ~ dnorm(x_ic,tau_ic)
  lam[1] ~ dnorm(x_ic,tau_ic)
  #S_add[1] ~ dnorm(x_ic, tau_ic) # runs without


  beta1~dnorm(0,0.01)
  beta2~dnorm(0,0.01)
  beta3~dnorm(0,0.01)
  beta4~dnorm(0,0.01)
  beta5~dnorm(0,0.01)

  alpha1~dlnorm(0,0.001) #log normal variance can't be negative
  alpha2~dlnorm(0,0.001) #log normal variance can't be negative

  tau_obs ~ dgamma(a_obs,r_obs)
  #tau_add ~ dgamma(a_proc,r_proc)

}
"

j.model_Hetero   <- jags.model (file = textConnection(mod1),
                             data = data,
                             inits = init,
                             n.chains = 3)  



jags.out_Hetro   <- coda.samples (model = j.model_Hetero,
                            variable.names = c("tau_obs","beta3","beta4","beta5", "alpha1", "alpha2"), #"tau_add",
                            n.iter = 10000)
plot(jags.out_Hetro)

summary(jags.out_Hetro)

DL_var.mat <- as.matrix(jags.out_Hetro)
pairs(DL_var.mat)
cor(DL_var.mat)
  

# Calculate DIC
DIC.hetero <- dic.samples(j.model_Hetero, n.iter=5000)
DIC.hetero #lower than homo
  
```

